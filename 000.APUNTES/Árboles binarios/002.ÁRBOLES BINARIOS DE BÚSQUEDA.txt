hash->tabla[indice].dato = dato
Hash cerrado: arreglo de campos
Hash abierto: arreglo de listas que contienen campos
---------------------------------------

ÁRBOLES BINARIOS DE BÚSQUEDA


* El árbol binario (común) sirve como diccionario? NO, porque es más complicado que una lista y encima siempre cuesta O(N) acceder a los elementos.


* Para implementar un diccionario usaremos un Árbol Binario de Búsqueda o (ABB), o Binary Search Tree (BST) en inglés.


* Para diccionarios, HASH O ABB? -->> ¿Queremos las claves ordenadas? ABB. ¿Queremos velocidad de acceso a los datos o no nos importa el orden? Hash.


* Recorrer un ABB usando inorder() SIEMPRE arroja una salida ORDENADA debido la naturaleza de la inserción de los datos en los ABB y del recorrido inorder.
>>>>> INORDER: En cada nodo iterado, mostramos primero el nodo hijo izquierdo, luego el nodo padre, y luego el nodo derecho
>>>>> ABB: En cada nodo, todo el ABB a su izquierda es menor y todo el ABB a su derecha es mayor


* La búsqueda en un ABB es similar a búsqueda binaria, por lo tanto su orden es O(log n).


* Tanto la búsqueda como el guardado usan el mismo algoritmo de búsqueda


* CASO PATOLÓGICO: Si insertamos ya ordenado, el orden degenera en O(n), porque el ABB básicamente se convierte en una lista. Esto se soluciona con los AVL.


* BORRADO: 0 hijos, 1 hijo, 2 hijos
0 HIJOS: Se busca y se borra de una.
---
1 HIJO: Se borra el nodo (no los hijos también), y todos sus hijos se ubican del mismo lado que el nodo borrado. (ver ppt abb borrar)
---
2 HIJOS: colocamos en su lugar el nodo inmediatamente anterior del elemento borrado, que es el máximo de la izquierda (todo a la derecha), o el nodo inmediatamente próximo del elemento borrado, que es el mínimo del lado derecho (todo a la izquierda). Borramos el nodo que usamos para reemplazar el borrado. (revisar Wikipedia). Básicamente, el menor de la derecha o el mayor de la izquierda es un reemplazante. Aplicamos borrado en el nodo reemplazante (en su posición original), de 0 o 1 nodos según corresponda.


* Insertar un elemento cuesta O(log N) (porque utiliza el algoritmo de búsqueda que es O(log N), más insertar el elemento que cuesta O(1)).


* Insertar N elementos cuesta O(N * log N).


* Borrar elementos cuesta O(log N) (porque implica buscar el nodo, y el algoritmo de búsqueda cuesta O(log N), más el borrado, que cuesta O(1)).


* Para borrar podemos buscar dos veces, o usar nodo_t** para hacer referencia al elemento que lo reemplazará (ver clase de nuevo).


* (VERIFICAR) Calcular la altura de un ABB es O(N). 


* EJERCICIO: Invertir un árbol (ver ppt), nota: es igual invertir de abajo para arriba (postorder) o de arriba para abajo (preorder)  -->>  orden O(N).


----------------------------------------------------------

¿TODO MUY LINDO PERO, COMO SE ALMACENAN LAS CLAVES EN UN ABB?

* Recorremos por clave, no por dato
* Las claves son alfanuméricas (char*)
* Los strings pueden tener cualquier largo
* Como los strings pueden tener cualquier largo, no hace falta hashearlos
* Como los strings pueden tener cualquier largo, necesitamos una función de comparación de strings
* "Bárbara" nos pasa la función de comparación de strings

EN RESUMEN, EJEMPLOS DE CLAVES (CLAVES FINALES, ALMACENADAS EN MEMORIA):
* Arreglo  -->>  0,1,2,3,4...
* Hash     -->>  "aa0", "ab2", "cef", "d3e"...
* ABB      -->>  "Carlitos", "Juan", "María Magdalena", "2"...  (se necesita una función que defina cuál es mayor a cual)


