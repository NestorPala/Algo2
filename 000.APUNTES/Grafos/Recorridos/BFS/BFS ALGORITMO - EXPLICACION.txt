BFS

Este algoritmo aplica tanto a grafos dirigidos como no dirigidos, pero tener en cuenta que en el caso de los grafos dirigidos, el algoritmo podria no llegar a todas partes; en ese caso hacemos un for para recorrer todos los vertices, y los ya visitados se descartan.

-------------------------------------------------------------------------------------------------------
PASOS BFS


1. Hacemos una tabla de Padre, Orden y Visitados:
	* Padre: 	diccionario (clave: nodo, valor: padre)
	* Orden: 	diccionario (clave: nodo, valor: orden)
	* Visitados:	set(nodo) (usamos set porque es O(1))

2. Creamos una cola para guardar los elementos que se "estan procesando".

3. Elegimos un vertice aleatorio para comenzar.

4. Agregamos el primer vertice a la tabla con los valores:
	Padre		Orden		Visitados
	-------		-----		---------
	1: None		 1: 0		    1

5. Guardamos el primer elemento en la cola.

6. Preguntamos si la cola esta vacia:
	* Si la cola esta vacia, se termino el recorrido.
	* Si no, desencolamos el primer elemento y buscamos todos sus adyacentes.

7. Por CADA NODO adyacente:
	7.1. Preguntamos si ya fue visitado
		* Si ya fue visitado no hacemos nada
		* Si NO fue visitado, lo guardamos en la tabla con los valores:
			
			Padre			Orden			Visitados
			----------------	-----------------	---------
			1: None			1: 0		            1
			   .			  .			    .
			   .			  .			    .
			   .			  .			    .
			X: Nodo a traves	X: El orden de su	    X
			   del cual		   padre + 1
			   llegue a X

	7.2. Guardamos el nodo en la cola.

8. Volvemos al paso 6.

-------------------------------------------------------------------------------------------------------
NOS QUEDA:


BFS(grafo, origen)
	* Pasos 1 a 4
	* Pasos 5 a 8 en un while

-------------------------------------------------------------------------------------------------------
COMPLEJIDAD:

Encolamos V veces y por cada nodo miramos sus adyacentes: en total vemos todas las aristas por lo menos una vez, y hasta 2 veces en el caso de grafos no dirigidos, asi que nos queda O(V + E). Pero esto porque utilizamos listas de adyacencia con diccionarios y sets, para los cuales sus operaciones principales se hacen en O(1).
